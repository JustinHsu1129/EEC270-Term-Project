# Chipyard Tutorial Part 4: Integrating Custom Verilog (Blackboxing)

This section explains how to incorporate existing Verilog (or SystemVerilog) code into your Chipyard SoC. In Chisel, this is called **Blackboxing**. This is essential if you have legacy IP or modules generated by other tools that you want to connect to the Chipyard memory map.

## 1. The Concept: Wrapping Layers

Since Chipyard is generated in Chisel, it cannot natively "read" Verilog logic. Instead, we create a **Chisel Wrapper** that defines the inputs and outputs (IO) of your Verilog module. We then wrap *that* wrapper in the **Diplomacy** logic (from Part 3) to connect it to the system bus.

---

## 2. Step 1: The Verilog Source

First, create your Verilog file. The file must reside in a location where the build system can find it. The standard convention in Chisel projects is the `src/main/resources` folder.

**File:** `generators/chipyard/src/main/resources/vsrc/MyAdder.v`

```verilog
module MyAdder(
    input         clock,
    input         reset,
    input  [31:0] operand_a,
    input  [31:0] operand_b,
    output [31:0] sum
);
    // Simple combinational logic
    assign sum = operand_a + operand_b;
endmodule

```

---

## 3. Step 2: The Chisel Blackbox Interface

Create a Chisel class that maps 1:1 to the Verilog module's ports.

**File:** `generators/chipyard/src/main/scala/example/MyAdderBlackbox.scala`

```scala
package chipyard.example

import chisel3._
import chisel3.util._

// 1. Define the IO Bundle that matches the Verilog
class MyAdderIO extends Bundle {
    val clock = Input(Clock())
    val reset = Input(Bool())
    val operand_a = Input(UInt(32.W))
    val operand_b = Input(UInt(32.W))
    val sum       = Output(UInt(32.W))
}

// 2. Define the Blackbox Class
// 'HasBlackBoxResource' allows us to attach the .v file automatically
class MyAdder extends BlackBox with HasBlackBoxResource {
    val io = IO(new MyAdderIO)

    // 3. Point to the Verilog file in resources
    // This looks in src/main/resources/vsrc/MyAdder.v
    addResource("/vsrc/MyAdder.v")
}

```

---

## 4. Step 3: The Diplomacy Integration (TileLink)

Now we integrate this Blackbox into the memory map, similar to how we created the PWM in Part 3. We will map registers to the inputs and outputs of the Verilog blackbox.

**File:** `generators/chipyard/src/main/scala/example/MyAdderPeripheral.scala`

```scala
package chipyard.example

import chisel3._
import freechips.rocketchip.config.Parameters
import freechips.rocketchip.diplomacy._
import freechips.rocketchip.regmapper._
import freechips.rocketchip.tilelink._

class MyAdderPeripheral(params: MyDeviceParams)(implicit p: Parameters) 
  extends TLRegisterRouter(
    base = params.address,
    devname = "myadder",
    compat = Seq("ucb,myadder"),
    beatBytes = 4
  )(
    new LazyModuleImp(_) {
      // 1. Instantiate the Chisel Blackbox
      val blackbox = Module(new MyAdder)

      // 2. Wire up Clock and Reset
      // Note: Chisel provides 'clock' and 'reset' signals implicitly in LazyModuleImp
      blackbox.io.clock := clock
      blackbox.io.reset := reset

      // 3. Create Hardware Registers to hold data
      // We need registers to hold 'A' and 'B' so the Blackbox sees them continuously
      val reg_a = RegInit(0.U(32.W))
      val reg_b = RegInit(0.U(32.W))

      // 4. Connect Registers to Blackbox Inputs
      blackbox.io.operand_a := reg_a
      blackbox.io.operand_b := reg_b

      // 5. Create the Memory Map
      // 0x00: Read/Write reg_a
      // 0x04: Read/Write reg_b
      // 0x08: Read-Only blackbox sum
      regmap(
        0x00 -> Seq(RegField(32, reg_a)),
        0x04 -> Seq(RegField(32, reg_b)),
        0x08 -> Seq(RegField.r(32, blackbox.io.sum)) // .r means Read-Only
      )
    }
  )

```

---

## 5. Step 4: Hooking it up

This step is identical to Part 3. You need to:

1. Create a Trait (`CanHavePeripheryMyAdder`).
2. Add that trait to `DigitalTop`.
3. Add the Config Fragment (`WithMyAdder`) to your top-level configuration.

**(Refer to Part 3, Steps 2, 3, and 4 for the exact syntax, just replacing `PWM` with `Adder`).**

---

## 6. Syntax Guide: Blackboxing

| Class / Trait | Description | Syntax Note |
| --- | --- | --- |
| `BlackBox` | The base class for any module not written in Chisel. | `class X extends BlackBox` |
| `HasBlackBoxResource` | Trait to include Verilog source files from the Java resource path (preferred). | `addResource("/path/in/resources/file.v")` |
| `HasBlackBoxPath` | Trait to include Verilog from an absolute path (discouraged for portability). | `addPath("/home/user/file.v")` |
| `addResource` | Tells the compiler to copy the Verilog file into the build directory. | Must be inside the BlackBox class constructor. |
| `RegField.r` | Creates a Read-Only register map entry. | `RegField.r(width, signal)` |
| `RegField.w` | Creates a Write-Only register map entry. | `RegField.w(width, signal)` |

### Common Pitfalls

* **Clock/Reset Names:** Verilog usually expects `clk` or `clock`. Ensure your Chisel `IO` bundle names match the Verilog ports **exactly** (case-sensitive).
* **Pathing:** If `addResource` fails, ensure your file is actually in `generators/chipyard/src/main/resources/...`. If the directory doesn't exist, create it.
